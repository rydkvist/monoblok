import { compile, type JSONSchema } from 'json-schema-to-typescript';
import type { SpaceComponent, SpaceComponentsData } from '../../../commands/components/constants';
import { __dirname, capitalize, handleError, handleFileSystemError, toCamelCase, toPascalCase } from '../../../utils';
import type { GenerateTypesOptions } from './constants';
import { isStoryblokPropertyType } from '../../../utils/storyblok-schemas';
import { join, resolve } from 'node:path';
import { resolvePath, sanitizeFilename, saveToFile } from '../../../utils/filesystem';
import { readFileSync } from 'node:fs';
import type { ComponentPropertySchema } from '../../../types/schemas';

export interface ComponentGroupsAndNamesObject {
  componentGroups: Map<string, Set<string>>;
  componentNames: Set<string>;
}

interface ComponentFileDefinition {
  name: string;
  content: string;
}

// Constants
const STORY_TYPE = 'ISbStoryData';
const DEFAULT_TYPEDEFS_HEADER = [
  '// This file was generated by the storyblok CLI.',
  '// DO NOT MODIFY THIS FILE BY HAND.',
];

const getPropertyTypeAnnotation = (property: ComponentPropertySchema, prefix?: string, suffix?: string) => {
  if (isStoryblokPropertyType(property.type)) {
    return { type: property.type };
  }
  // Initialize property type as any (fallback type)
  let type: string | string[] = 'unknown';

  const options = property.options && property.options.length > 0 ? property.options.map((item: { value: string }) => item.value) : [];

  // Add empty option to options array
  if (options.length > 0 && property.exclude_empty_option !== true) {
    options.unshift('');
  }

  if (property.source === 'internal_stories') {
    // Only if there is a filter_content_type, we can return a proper type
    if (property.filter_content_type) {
      if (typeof property.filter_content_type === 'string') {
        return {
          tsType: `(${getStoryType(property.filter_content_type, prefix, suffix)} | string )${property.type === 'options' ? '[]' : ''}`,
        };
      }

      return {
        tsType: `(${property.filter_content_type
          .map(type2 => getStoryType(type2, prefix, suffix))
          // In this case property.type can be `option` or `options`. In case of `options` the type should be an array
          .join(' | ')} | string )${property.type === 'options' ? '[]' : ''}`,
      };
    }
  }

  if (
    // If there is no `source` and there are options, the data source is the component itself
    // TODO: check if this is an old behaviour (shouldn't this be handled as an "internal" source?)
    (options.length > 0 && !property.source)
    || property.source === 'internal_languages'
    || property.source === 'external'
  ) {
    type = 'string';
  }

  if (property.source === 'internal') {
    type = ['number', 'string'];
  }

  if (property.type === 'option') {
    if (options.length > 0) {
      return {
        type,
        enum: options,
      };
    }

    return {
      type,
    };
  }

  if (property.type === 'options') {
    if (options.length > 0) {
      return {
        type: 'array',
        items: {
          enum: options,
        },
      };
    }

    return {
      type: 'array',
      items: { type },
    };
  }

  switch (property.type) {
    case 'bloks':
      return { type: 'array' };
    case 'boolean':
      return { type: 'boolean' };
    case 'datetime':
    case 'image':
    case 'markdown':
    case 'number':
    case 'text':
    case 'textarea':
      return { type: 'string' };
    default:
      return { type: 'any' };
  }
};

export function getStoryType(property: string, prefix?: string, suffix?: string) {
  return `${STORY_TYPE}<${prefix ?? ''}${capitalize(toCamelCase(property))}${suffix ?? ''}>`;
}

/**
 * Generates a TypeScript type name for a component
 * @param componentName - The name of the component
 * @param options - Options for generating the type name
 * @returns The generated type name
 *
 * The type name can be customized with the following options:
 * - typePrefix: Prefix to be prepended to all generated component type names (can be set via --type-prefix flag)
 */
export const getComponentType = (
  componentName: string,
  options: GenerateTypesOptions,
): string => {
  const prefix = options.typePrefix ?? '';
  const suffix = options.typeSuffix ?? '';

  // Sanitize the component name to handle special characters and emojis
  const sanitizedName = componentName
    // Replace any character that's not a letter or number with an underscore
    .replace(/[^a-z0-9]/gi, '_')
    // Replace multiple consecutive underscores with a single underscore
    .replace(/_+/g, '_')
    // Trim underscores from the beginning and end
    .replace(/^_+|_+$/g, '');

  // Convert to PascalCase
  const componentType = toPascalCase(`${prefix}_${sanitizedName}_${suffix}`);

  // If the component type starts with a number, prefix it with an underscore
  const isFirstCharacterNumber = !Number.isNaN(Number.parseInt(componentType.charAt(0)));
  return isFirstCharacterNumber ? `_${componentType}` : componentType;
};

const getComponentPropertiesTypeAnnotations = async (
  component: SpaceComponent,
  options: GenerateTypesOptions,
  spaceData: SpaceComponentsData,
  customFieldsParser?: (key: string, value: Record<string, unknown>) => Record<string, unknown>,
): Promise<JSONSchema['properties']> => {
  return Object.entries(component.schema).reduce(async (accPromise, [key, value]) => {
    const acc = await accPromise;

    // Skip tabbed properties
    if (key.startsWith('tab-')) {
      return acc;
    }

    // Type guard to ensure value is ComponentPropertySchema
    if (!value || typeof value !== 'object' || !('type' in value)) {
      return acc;
    }

    const schema = value as ComponentPropertySchema;
    const propertyType = schema.type;
    const propertyTypeAnnotation: JSONSchema = {
      [key]: getPropertyTypeAnnotation(schema, options.typePrefix, options.typeSuffix),
    };

    if (propertyType === 'custom' && customFieldsParser) {
      const customField = typeof customFieldsParser === 'function' ? customFieldsParser(key, schema as unknown as Record<string, unknown>) : {};
      return {
        ...acc,
        ...customField,
      };
    }

    if (isStoryblokPropertyType(propertyType)) {
      // For Storyblok property types, don't apply the prefix
      const componentType = toPascalCase(propertyType);
      propertyTypeAnnotation[key].tsType = `Storyblok${componentType}`;
    }

    if (propertyType === 'multilink') {
      const excludedLinktypes: string[] = [
        ...(!schema.email_link_type ? ['{ linktype?: "email" }'] : []),
        ...(!schema.asset_link_type ? ['{ linktype?: "asset" }'] : []),
      ];
      const componentType = `Storyblok${toPascalCase(propertyType)}`;
      propertyTypeAnnotation[key].tsType
        = excludedLinktypes.length > 0 ? `Exclude<${componentType}, ${excludedLinktypes.join(' | ')}>` : componentType;
    }

    if (propertyType === 'bloks') {
      if (schema.restrict_components) {
        // Components restricted by groups
        if (schema.restrict_type === 'groups') {
          if (
            Array.isArray(schema.component_group_whitelist)
            && schema.component_group_whitelist.length > 0
          ) {
            // Find components that belong to the whitelisted groups
            const componentsInGroupWhitelist = schema.component_group_whitelist.reduce(
              (components: string[], groupUUID: string) => {
                // Find components that have this group UUID
                const componentsInGroup = spaceData.components.filter(
                  component => component.component_group_uuid === groupUUID,
                );

                return componentsInGroup.length > 0
                  ? [
                      ...components,
                      ...componentsInGroup.map(component => getComponentType(component.name, options)),
                    ]
                  : components;
              },
              [],
            );

            propertyTypeAnnotation[key].tsType
              = componentsInGroupWhitelist.length > 0 ? `(${componentsInGroupWhitelist.join(' | ')})[]` : `never[]`;
          }
        }
        else if (schema.restrict_type === 'tags') {
          // Components restricted by tags
          if (Array.isArray(schema.component_tag_whitelist) && schema.component_tag_whitelist.length > 0) {
            // Find components that have any of the whitelisted tag IDs
            const componentsWithTags = spaceData.components.filter(
              component =>
                component.internal_tag_ids
                && component.internal_tag_ids.some(tagId =>
                  schema.component_tag_whitelist!.includes(Number(tagId)),
                ),
            );

            propertyTypeAnnotation[key].tsType
              = componentsWithTags.length > 0
                ? `(${componentsWithTags.map(component => getComponentType(component.name, options)).join(' | ')})[]`
                : `never[]`;
          }
        }
        else {
          // Components restricted by 1-by-1 list
          if (Array.isArray(schema.component_whitelist) && schema.component_whitelist.length > 0) {
            propertyTypeAnnotation[key].tsType = `(${schema.component_whitelist
              .map((name: string) => getComponentType(name, options))
              .join(' | ')})[]`;
          }
        }
      }
      else {
        // All components can be slotted in this property (AKA no restrictions)
        // Add null check to ensure spaceData.components is defined
        if (spaceData && Array.isArray(spaceData.components)) {
          propertyTypeAnnotation[key].tsType = `(${spaceData.components
            .map(component => getComponentType(component.name, options))
            .join(' | ')})[]`;
        }
        else {
          // Fallback to never[] if components is undefined
          propertyTypeAnnotation[key].tsType = `never[]`;
        }
      }
    }

    return { ...acc, ...propertyTypeAnnotation };
  }, Promise.resolve({} as JSONSchema));
};

const loadCustomFieldsParser = async (path: string): Promise<((key: string, value: Record<string, unknown>) => Record<string, unknown>) | undefined> => {
  try {
    const customFieldsParser = await import(resolve(path));
    return customFieldsParser.default;
  }
  catch (error) {
    handleError(error as Error);
    return undefined;
  }
};

async function loadCompilerOptions(path: string) {
  if (path) {
    const compilerOptions = await import(resolve(path));
    return compilerOptions.default;
  }
  return {};
}

const getRequiredFields = (schema: Record<string, any> | undefined): string[] => {
  return Object.entries(schema || {}).reduce<string[]>(
    (acc, [_, v]) => (v && typeof v === 'object' && 'required' in v && (v as any).required ? [...acc, _] : acc),
    ['component', '_uid'],
  );
};

const collectUsedTypesFromProps = (
  props: JSONSchema['properties'] | undefined,
  used: Set<string>,
) => {
  if (!props) return;
  Object.values(props).forEach((property) => {
    if (property?.type && isStoryblokPropertyType(property.type)) {
      used.add(property.type);
    }
    if (property?.tsType?.includes(STORY_TYPE)) {
      used.add(STORY_TYPE);
    }
  });
};

const buildImportsFromUsedTypes = (
  used: Set<string>,
  { relativeStoryblokDts = '../storyblok.d.ts', removeISb = true } = {},
): string[] => {
  const lines: string[] = [];

  if (used.has(STORY_TYPE)) {
    lines.push(`import type { ${STORY_TYPE} } from '@storyblok/js';`);
    if (removeISb) used.delete(STORY_TYPE);
  }

  if (used.size > 0) {
    const typeImports = Array.from(used).map(t => `Storyblok${toPascalCase(t)}`);
    lines.push(`import type { ${typeImports.join(', ')} } from '${relativeStoryblokDts}';`);
  }

  return lines;
};

/**
 * Maps a Storyblok component into:
 * - computed JSONSchema
 * - per-component used Storyblok helper types (for imports)
 * - the generated TypeScript interface name (title)
 */
const buildSchemaForComponent = async (
  component: SpaceComponent,
  options: GenerateTypesOptions,
  spaceData: SpaceComponentsData,
  customFieldsParser?:
    | ((key: string, value: Record<string, unknown>) => Record<string, unknown>)
    | undefined,
) => {
  const used = new Set<string>();
  const title = getComponentType(component.name, options);

  const props = await getComponentPropertiesTypeAnnotations(
    component,
    options,
    spaceData,
    customFieldsParser,
  );

  collectUsedTypesFromProps(props, used);
  const required = getRequiredFields(component?.schema);

  const schema: JSONSchema = {
    $id: `#/${component.name}`,
    title,
    type: 'object',
    required,
    properties: {
      ...props,
      component: { type: 'string', enum: [component.name] },
      _uid: { type: 'string' },
    },
  };

  return { schema, used, title };
};

export const generateTypes = async (
  spaceData: SpaceComponentsData,
  options: GenerateTypesOptions = { strict: false },
): Promise<string | ComponentFileDefinition[] | undefined> => {
  try {
    const header = [...DEFAULT_TYPEDEFS_HEADER];

    let customFieldsParser:
      | ((key: string, value: Record<string, unknown>) => Record<string, unknown>)
      | undefined;
    let compilerOptions: Record<string, unknown> | undefined;

    if (options.customFieldsParser) {
      customFieldsParser = await loadCustomFieldsParser(options.customFieldsParser);
    }
    if (options.compilerOptions) {
      compilerOptions = await loadCompilerOptions(options.compilerOptions);
    }

    if (options.separateFiles) {
      const perComponent = await Promise.all(
        spaceData.components.map(async (component) =>
          buildSchemaForComponent(component, options, spaceData, customFieldsParser),
        ),
      );

      const files: ComponentFileDefinition[] = await Promise.all(
        perComponent.map(async ({ schema, used }) => {
          const code = await compile(schema, schema.title!, {
            additionalProperties: !options.strict,
            bannerComment: '',
            ...compilerOptions,
          });

          const imports = buildImportsFromUsedTypes(used, {
            relativeStoryblokDts: '../storyblok.d.ts',
            removeISb: true,
          });

          return {
            name: sanitizeFilename(schema.$id?.replace('#/', '') || ''),
            content: [...header, ...imports, code].join('\n'),
          };
        }),
      );

      return files;
    }

    const globalUsed = new Set<string>();

    const mapped = await Promise.all(
      spaceData.components.map(async (component) =>
        buildSchemaForComponent(component, options, spaceData, customFieldsParser),
      ),
    );

    mapped.forEach(({ used }) => used.forEach(t => globalUsed.add(t)));

    const compiled = await Promise.all(
      mapped.map(({ schema }) =>
        compile(schema, schema.title!, {
          additionalProperties: !options.strict,
          bannerComment: '',
          ...compilerOptions,
        }),
      ),
    );

    const imports = buildImportsFromUsedTypes(globalUsed, {
      relativeStoryblokDts: '../storyblok.d.ts',
      removeISb: true,
    });

    const finalTypeDef = [...header, ...imports, ...compiled];
    return [...finalTypeDef].join('\n');
  } catch (error) {
    handleError(error as Error);
    return undefined;
  }
};

export const saveTypesToFile = async (
  space: string,
  typedef: string | ComponentFileDefinition[],
  options: SaveTypesOptions,
) => {
  const { filename = 'storyblok-components', path, separateFiles } = options;

  const resolvedPath = path
    ? resolve(process.cwd(), path, 'types', space)
    : resolvePath(path, `types/${space}`);

  try {
    if (separateFiles && Array.isArray(typedef)) {
      for (const { name, content } of typedef) {
        await saveToFile(join(resolvedPath, `${name}.d.ts`), content);
      }
      return;
    }

    await saveToFile(join(resolvedPath, `${filename}.d.ts`), typedef as string);
  } catch (error) {
    handleFileSystemError('write', error as Error);
  }
};

// Add SaveTypesOptions interface
export interface SaveTypesOptions extends Pick<GenerateTypesOptions, 'filename' | 'path' | 'separateFiles'> {}

/**
 * Generates a d.ts file with the Storyblok type definitions
 * @param options - Options for generating the types
 * @returns Promise that resolves when the file is saved
 */
export const generateStoryblokTypes = async (options: SaveTypesOptions = {}) => {
  const { filename = 'storyblok', path } = options;

  try {
    // Get the path to the storyblok.ts file

    const storyblokTypesPath = resolve(__dirname, './index.d.ts');
    // Read the content of the storyblok.ts file
    const storyblokTypesContent = readFileSync(storyblokTypesPath, 'utf-8');

    // Define the content of the d.ts file
    const typeDefs = [
      '// This file was generated by the Storyblok CLI.',
      '// DO NOT MODIFY THIS FILE BY HAND.',
      `import type { ${STORY_TYPE} } from '@storyblok/js';`,
      storyblokTypesContent,
    ].join('\n');

    // Determine the path to save the file
    const resolvedPath = path
      ? resolve(process.cwd(), path, 'types')
      : resolvePath(path, 'types');

    await saveToFile(join(resolvedPath, `${filename}.d.ts`), typeDefs);
    return true;
  }
  catch (error) {
    handleFileSystemError('read', error as Error);
    return false;
  }
};
